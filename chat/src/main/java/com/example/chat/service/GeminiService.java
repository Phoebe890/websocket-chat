package com.example.chat.service;

import com.example.chat.model.GeminiRequest;
import com.example.chat.model.GeminiResponse;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.stereotype.Service;
import org.springframework.web.reactive.function.client.WebClient;

import java.util.concurrent.CompletableFuture;

@Service
public class GeminiService {

    // Injects the API key from application.properties.
    @Value("${gemini.api.key}")
    private String geminiApiKey;

    private final WebClient webClient;

    public GeminiService(WebClient.Builder webClientBuilder) {
        // We configure a WebClient instance pointing to the base Gemini API URL.
        this.webClient = webClientBuilder
            .baseUrl("https://generativelanguage.googleapis.com/v1beta/models/gemini-pro:generateContent")
            .build();
    }

    /**
     * Sends a prompt to the Gemini API and returns the response asynchronously.
     */
    public CompletableFuture<String> getAIResponse(String prompt) {
        // Create the structured request object using the user's prompt.
        GeminiRequest requestBody = new GeminiRequest(prompt);

        return webClient.post()
                // The Gemini API requires the key to be sent as a URL query parameter.
                .uri(uriBuilder -> uriBuilder.queryParam("key", geminiApiKey).build())
                .bodyValue(requestBody) // Set the request body.
                .retrieve() // Execute the request.
                .bodyToMono(GeminiResponse.class) // Convert the JSON response into our GeminiResponse object.
                .map((GeminiResponse response) -> {
                    // This logic safely navigates through the nested response structure
                    // to extract the final text content generated by the AI.
                    if (response != null && response.getCandidates() != null && !response.getCandidates().isEmpty()) {
                        return response.getCandidates().get(0).getContent().getParts().get(0).getText();
                    }
                    return "Sorry, I am unable to provide a response at this time.";
                })
                .toFuture(); // Convert the reactive result into a CompletableFuture for our controller.
    }
}